# Drosera unique trap
THis unique trap is checking if your wallet address receives needed tekens sum and if they came from address you expect. If both evebts are TRUE, so function triggers event.


## This trap could be used for:

- For expected sender income;  Your friend sends 0.00005 ETH and this is your expectation; 
- Monitoring if you are not waiting for such an amount from that address;
- Verification of payment - you know when that amount is paid.

## Deployment
   - Add the contract to your drosera.toml configuration under [[traps]].
   - Compile the contract with drosera build.
   - Apply the configuration with drosera apply.
   - Start your operator and monitor the dashboard/logs.
When the target wallet receives 0.00005 ETH, the trap will trigger and show a dark green block in the dashboard.

## LogAlertReceiver

In addition to the trap, also provides an example alert receiver contract called LogAlertReceiver.sol.
Its purpose:

   - To listen for alerts generated by the trap
   - To emit on-chain log events when the trap condition is met
   - To make it easier to test and debug trap execution results

Typical usage:
   - Deploy LogAlertReceiver alongside the trap
   - Configure Drosera so that alerts from the trap are delivered to the receiver
   - Watch emitted logs on-chain or in your node logs

## License

This project is licensed under the MIT License.

## Trap Code

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ITrap {
    function collect() external view returns (bytes memory);
    function shouldRespond(bytes[] calldata data) external pure returns (bool, bytes memory);
}

contract IncomingFromSpecificSenderTrap is ITrap {
    address public constant target = YOUR_WALLET_HERE; // your wallet address 0x.......
    address public constant senderFilter = WALLET_WHICH_SENDS_TO_YOU; // this sender only address wallet 0x.......

    uint256 public constant minAmount = 0.00005 ether; // incoming transfer amount

    function collect() external view override returns (bytes memory) {
        return abi.encode(target.balance);
    }

    function shouldRespond(bytes[] calldata data) external pure override returns (bool, bytes memory) {
        if (data.length < 2) return (false, "Insufficient data");

        uint256 current = abi.decode(data[0], (uint256));
        uint256 previous = abi.decode(data[1], (uint256));

        if (current > previous) {
            uint256 diff = current - previous;

            if (diff >= minAmount) {
                return (true, abi.encode(senderFilter));
            }
        }

        return (false, "");
    }
}

```
## LogAlertReceiver Code

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract LogAlertReceiver {
    event Alert(string message);

    // This function call emits event
    function RezultHere(string calldata message) external {
        emit Alert(message);
    }
}
